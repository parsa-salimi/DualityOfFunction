#lang racket
(require "DNF.rkt")
(require "generator.rkt")
(require "fk-1.rkt")
(require pict)
(require pict/tree-layout)
(require file/convertible)
(require racket/vector)
; A tree is recursively defined as :
; #f (a terminal node
; a list '(node l r), where node is a node(currently stores frequency/ index information, and l and r are trees
(define (node tree) (car tree))
(define (left-tree tree) (cadr tree))
(define (right-tree tree) (caddr tree))
(define (node-leaf? tree) (member #t tree))
(define (empty-tree? tree) (not (list? tree)))
(define (leafcount tree)
  (cond [(empty-tree? tree) 1]
        [else (+ (leafcount (left-tree tree)) (leafcount (right-tree tree)))]))


;a 30*30 array
(define gridcounters (build-vector 30 (lambda (x) (make-vector 30 0))))

;generates a #tree-layout from a given tree, which can be used to visualise the tree
(define (tree->pict tree)
  (cond [(empty-tree? tree) (tree-layout #:pict(disk #:color "blue" 15))]
        [else (tree-layout #:pict(text (format "~a"  (node tree))) (tree->pict (left-tree tree)) (tree->pict (right-tree tree)))]))

(define (simpledisjunction? f g)
  (define (listofones g)
    (cond [(empty? g) #t]
          [(= (length (first g)) 1) (listofones (rest g))]
          [else #f]))
  (and (= (length f) 1)
       (listofones g)))
;the following returns a computation tree
(define (FK-treelist f g pivot tiebreaker)
    (cond [(or (empty? f) (empty? g)) #t]
          [ (not (sanitycheck f g)) (sanitycheck f g)]
          [ (<= (* (clause-len f) (clause-len g)) 1) (if (easydual f g) #t #f)]
          [(simpledisjunction? f g) #t] ;catches formulas of the form f: /\_i x_i g: \/_i x_i
          [(simpledisjunction? g f) #t]
          [ (and (= (+ (length f) (length g)) 3) (equal? (sort (flatten f) <) (sort (flatten g) <))) #t]
          [ else
            (letrec ((x (tiebreaker (pivot (vars f) f g)))
                          (f0 (remove-var f x))
                          (f1 (remove-clause f x))
                          (g0 (remove-var g x))
                          (g1 (remove-clause g x)))
                 (list (list f g) ;node
                       (FK-treelist (reduce f1) (reduce  (disjunction g0 g1)) pivot tiebreaker) ;left subtree
                       (FK-treelist (reduce (disjunction f0 f1)) (reduce g1) pivot tiebreaker)))])) ;right subtree


;treepict is a <tree-layout> (generated by passing a treelist into tree->pict
;spacing is the y-spacing between the nodes, set to #f for default spacing
(define (generate-svg treepict filename space)
  (define output (open-output-file filename))
  (fprintf output (bytes->string/utf-8
                                        (convert (naive-layered treepict  #:x-spacing (first space) #:y-spacing (second space)) 'svg-bytes)))
  (close-output-port output))

(define (gridgen-pivot pivotlist tblist)
  (define possibilities (cartesian-product pivotlist tblist))
  (for-each (lambda (x) (begin
                          (display (string-replace (string-replace (format "~a ~a" (first x) (second x)) "#<procedure:" "") ">" ""))
                          (printf ":  ~a \n" (leafcount (FK-treelist (f-n 3) (g-n 3) (first x) (second x)))))) possibilities))

(define (arrayset dim1 dim2 array)
  (vector-set! (vector-ref array dim1) dim2 (+ 1 (vector-ref (vector-ref array dim1) dim2))))
(define (arrayclear array)
  (vector-map (lambda (y) (vector-fill! y 0)) array))

(define (gridgen tree)
  (arrayclear gridcounters)
  (define (gridgen-help tree leftcount rightcount)
    (cond [(empty-tree? tree)  (arrayset leftcount rightcount gridcounters)]
          [else   (begin (gridgen-help (left-tree tree) (+ 1 leftcount) rightcount) (gridgen-help (right-tree tree) leftcount (+ 1 rightcount)))]))
  (gridgen-help tree 0 0))

;must first run gridgen to write the values on gridcounters
(define (generate-csv filename)
  (define outputport (open-output-file filename))
  (vector-map (lambda (x)
             (vector-map (lambda (y) (fprintf outputport "~a," y)) x)
             (fprintf outputport "\n"))
             gridcounters)
  (close-output-port outputport))

(define (generate-all-grids pivotlist tblist k)
  (define possibilities (cartesian-product pivotlist tblist))
  (for-each (lambda (x)
              (gridgen (FK-treelist (f-n k) (g-n k) (first x) (second x)))
              (generate-csv (string-replace (string-replace (format "csv\\~a-~a-f~a-symmetric.csv" (first x) (second x) k) "#<procedure:" "") ">" "")))
            possibilities))


                   