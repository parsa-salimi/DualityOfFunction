#lang racket
(require "DNF.rkt" "generator.rkt" "fk-1.rkt" "profilegen.rkt" "dualgen.rkt" "getfunctions.rkt" "patternmatcher.rkt" pict pict/tree-layout file/convertible racket/vector racket/string racket/set)
(provide node left-tree right-tree empty-tree? FK-treelist generate-svg generate-csv find nodeat parents)
; A tree is recursively defined as :
; '(#t/#f '(f g)) : a terminal node, f and g are formulas
; a list '(node l r), where l and r are trees, and node is '(f g) where f and g are formulas at the node
(define (node tree) (car tree))
(define (left-tree tree) (cadr tree))
(define (right-tree tree) (caddr tree))
(define (empty-tree? tree) (or (eq? (first tree) #t) (eq? (first tree) #f)))
(define (tree->list tree)
  (cond
    [(empty-tree? tree) (list (second tree))]
    [else (append  (list (node tree)) (tree->list (left-tree tree)) (tree->list (right-tree tree)))]))

;counts all the nodes in the tree satisfying f: (MBF,MBF) -> (#t/#f)
(define (treecount tree f)
  (define (treecount-help tree f count)
    (cond
      [(empty-tree? tree) (if (f (second tree)) 1 0)]
      [else (+ (treecount-help (left-tree tree) f 0)
               (treecount-help (right-tree tree) f 0)
               (if (f (node tree)) 1 0))]))
  (treecount-help tree f 0))

;number of leaf nodes in tree
(define (leafcount tree)
  (cond [(empty-tree? tree) 1]
        [else (+ (leafcount (left-tree tree)) (leafcount (right-tree tree)))]))

(define (simpledisjunction? f g)
  (define (listofones g)
    (cond [(empty? g) #t]
          [(= (length (first g)) 1) (listofones (rest g))]
          [else #f]))
  (and (= (length f) 1)
       (listofones g)))

;the following returns a computation tree
(define (FK-treelist-guided f g pivot tiebreaker varlist pivotlist)
    (cond [(or (empty? f) (empty? g)) (list #t (list f g))]
          [ (not (sanitycheck f g)) (list #f (list f g))]
          [ (<= (* (clause-len f) (clause-len g)) 1) (if (first (easydual f g varlist)) (list #t (list f g)) (list #f (list f g)))]
          [(simpledisjunction? f g)  (list #t (list f g))] ;catches formulas of the form f: /\_i x_i g: \/_i x_i
          [(simpledisjunction? g f)  (list #t (list f g))]
          [ else
            (letrec ((x (if (empty? pivotlist) (tiebreaker (pivot (sort (vars f) <) f g)) (first pivotlist)))
                          (f0 (remove-var f x))
                          (f1 (remove-clause f x))
                          (g0 (remove-var g x))
                          (g1 (remove-clause g x)))
                 (list (list f g) ;node
                       (FK-treelist-guided (reduce f1) (reduce  (disjunction g0 g1)) pivot tiebreaker (remove x varlist) (if (empty? pivotlist) '() (rest pivotlist))) ;left subtree
                       (FK-treelist-guided (reduce (disjunction f0 f1)) (reduce g1) pivot tiebreaker (remove x varlist) (if (empty? pivotlist) '() (rest pivotlist)))))])) ;right subtree
(define (FK-treelist f g pivot tiebreaker)
  (FK-treelist-guided f g pivot tiebreaker (vars f) '()))

;treepict is a <tree-layout> (generated by passing a treelist into tree->pict
;arguements: space (list Int/#f Int/#f): the x and y spacing between the nodes, in pixels. set to #f for default spacing.
;            minimal? #t/#f : specify if the generated tree visualization should include the clauses at each node
(define (generate-svg tree filename space minimal)
  ;generates a #tree-layout from a given tree, which can be used to visualise the tree.
  (define (tree->pict tree minimal?)
    (cond [(empty-tree? tree) (if minimal? (tree-layout) (tree-layout #:pict(text (format "~a"  (second tree)))))]
        [else  (if minimal?
                   (tree-layout (tree->pict (left-tree tree) #t) (tree->pict (right-tree tree) #t))
                   (tree-layout #:pict(text (format "~a"  (node tree))) (tree->pict (left-tree tree) #f) (tree->pict (right-tree tree) #f)))]))
  (define output (open-output-file filename))
  (fprintf output (bytes->string/utf-8
  (convert (naive-layered (tree->pict tree minimal)  #:x-spacing (first space) #:y-spacing (second space)) 'svg-bytes)))
  (close-output-port output))

;returns a 2D hash table corresponding to the grid, used in the next function.
(define (gridgen tree)
  (define myhash (make-table (length (vars (first (node tree))))))
  (define leftcount-max 0)
  (define (gridgen-help tree leftcount rightcount)
    (when (> leftcount leftcount-max) (set! leftcount-max leftcount))
    (cond [(empty-tree? tree) (K(rightcount leftcount) += 1 in myhash)]
          [else   (begin (gridgen-help (left-tree tree) (+ 1 leftcount) rightcount) (gridgen-help (right-tree tree) leftcount (+ 1 rightcount)))]))
  (gridgen-help tree 0 0)
  (list myhash leftcount-max))

(define (generate-csv filename tree)
  (define outputport (open-output-file filename))
  (letrec ([gridgen-res (gridgen tree)]
           [hash (first gridgen-res)]
           [depth (second gridgen-res)])
   (for ([i (range 0 (+ 1 (length (vars (first (node tree))))))])
     (for([j (range 0 (+ 1 depth))])
       (fprintf outputport "~a," (K(j i) in hash)))
     (fprintf outputport "\n"))
  (close-output-port outputport)))

;generates grids corresponding to all tiebreaking and pivot rules in pivotlist and tblist
(define (generate-all-grids pivotlist tblist f g)
  (define possibilities (cartesian-product pivotlist tblist))
  (for-each (lambda (x)
              (generate-csv (string-replace (string-replace (format "csv\\~a-~a-~a.csv" (first x) (second x) f g) "#<procedure:" "") ">" "")
                        (FK-treelist f g (first x) (second x) (vars f))))    
            possibilities))

(define (generate-small-trees n pivot tb)
  (letrec ( [funcs (duals n)]
            [trees (map (lambda (fg) (FK-treelist (first fg) (second fg) pivot tb (vars (first fg)))) funcs)]
            [nontrivial-trees (filter (lambda (x) (= (treecount x (lambda (t) #t)) 7)) trees)]
            [sortedtrees (sort nontrivial-trees (lambda (x y) (< (treecount x (lambda (t) #t)) (treecount y (lambda (t) #t)))))])
    (for ([tree sortedtrees]
          [i (range 0 (+ 1 (length sortedtrees)))])
      (generate-svg  tree
                (string-replace (string-replace (format "smalltrees\\size~a\\~a~arank~a.svg" n pivot tb i) "#<procedure:" "") ">" "") '(10 20) #f))))

(define (find tree formula)
  (define (fhelp tree formula current-path pathlist)
    (cond [(empty-tree? tree) pathlist]
          [(or (equal? (first (node tree)) formula) (equal? (second (node tree)) formula)) (cons current-path pathlist)]
          [else (append (fhelp (right-tree tree) formula (string-append current-path "R") pathlist)
                        (fhelp (left-tree tree) formula (string-append current-path "L") pathlist))]))
  (fhelp tree formula "" empty))

(define (nodeat tree path-string)
  (define listed (string->list path-string))
   (cond [(empty? listed) (node tree)]
         [(eq? (first listed) #\L) (nodeat (left-tree tree) (list->string (cdr listed)))]
         [else (nodeat (right-tree tree) (list->string (cdr listed)))]))

(define (parents tree formula)
  (letrec  [ (mypath (find tree formula))
          (mypathmod (map (lambda (s) (substring s 0 (- (string-length s) 1))) mypath))
          (mynodes (map (lambda (s) (nodeat tree s)) mypathmod))]
  (remove-duplicates mynodes)))


   
(define var4types (make-hash))
(for [(type typelist)]
  (hash-set! var4types type 0))

(define (vartypes tree )
  (define nodelist (filter (lambda (x) (and (= (length (vars (first x))) 4) (= (length (vars (second x))) 4)))  (tree->list tree)))
  ;(printf "~a\n" (leafcount tree))
  (for [(type typelist)]
  (hash-set! var4types type 0))
  (define (update-typecount f)
    (for [(type typelist)]
      (when (is f type)
        (hash-set! var4types type (+ 1 (hash-ref var4types type))))))
  (for [(fpair nodelist)]
        (update-typecount fpair))
  (for ([(i j) var4types])
    (printf "~a\t" j)))


;playground for our experiments
;(define ac (list "ac_200k.dat" "ac_150k.dat" "ac_130k.dat" "ac_110k.dat"))
(define bms (list "bms2_400.dat" "bms2_200.dat" "bms2_100.dat"))
;(define connect4w (list "win100.dat" "win200.dat" "win400.dat" "win800.dat"))
(define connect4l (list "lose100.dat" "lose200.dat" "lose400.dat" "lose800.dat"))
(define matching (list "matching28.dat" "matching30.dat" "matching32.dat" "matching34.dat" "matching36.dat"))
;(define dual-matching (list "dualmatching30.dat" "dualmatching24.dat"
;                            "dualmatching28.dat" "dualmatching30.dat"))
(define thgraph (list "TH40.dat" "TH60.dat" "TH80.dat" "TH100.dat"))
(define sdthgraph (list "SDTH42.dat" "SDTH62.dat" "SDTH82.dat" "SDTH102.dat"))
(define sdfano (list "SDFP9.dat" "SDFP16.dat" "SDFP23.dat" "SDFP30.dat"))


(define pivotlist (list fnone fthresh fmax))
(for [(func (list thgraph))]
  (for [(pair (cartesian-product func pivotlist))]
   (letrec [(f (getf (string-append "http://research.nii.ac.jp/~uno/dualization/" (first pair))))
           (fd (dual f))
           (tree (FK-treelist f fd (second pair) tbfirst))]
    (print (string-append (string-replace (string-replace (first pair) "SDFP" "") ".dat" "")
           (string-replace (string-replace (format "~a" (second pair)) "#<procedure:" "-") ">" "")))
    (printf "\t")
    (vartypes tree))
    (newline)))




  


                        
                       

 