#lang racket
(require "DNF.rkt" "generator.rkt" "fk-1.rkt" "profilegen.rkt" "dualgen.rkt" "getfunctions.rkt" "patternmatcher.rkt" pict pict/tree-layout file/convertible racket/vector racket/string racket/set)
(provide node left-tree right-tree empty-tree? FK-treelist generate-svg generate-csv find nodeat parents)
; A tree is recursively defined as :
; '(#t/#f '(f g)) : a terminal node, f and g are formulas
; a list '(node l r), where l and r are trees, and node is '(f g) where f and g are formulas at the node
(define (node tree) (car tree))
(define (left-tree tree) (cadr tree))
(define (right-tree tree) (caddr tree))
(define (empty-tree? tree) (or (eq? (first tree) #t) (eq? (first tree) #f)))
(define (tree->list tree)
  (cond
    [(empty-tree? tree) (list (second tree))]
    [else (append  (list (node tree)) (tree->list (left-tree tree)) (tree->list (right-tree tree)))]))

;counts all the nodes in the tree satisfying f: (MBF,MBF) -> (#t/#f)
(define (treecount tree f)
  (define (treecount-help tree f count)
    (cond
      [(empty-tree? tree) (if (f (second tree)) 1 0)]
      [else (+ (treecount-help (left-tree tree) f 0)
               (treecount-help (right-tree tree) f 0)
               (if (f (node tree)) 1 0))]))
  (treecount-help tree f 0))

;number of leaf nodes in tree
(define (leafcount tree)
  (cond [(empty-tree? tree) 1]
        [else (+ (leafcount (left-tree tree)) (leafcount (right-tree tree)))]))

(define (simpledisjunction? f g)
  (define (listofones g)
    (cond [(empty? g) #t]
          [(= (clause-len (first-clause g)) 1) (listofones (rest-clauses g))]
          [else #f]))
  (and (= (size f) 1)
       (listofones g)))

;the following returns a computation tree
(define (FK-treelist-guided f g pivot tiebreaker varlist pivotlist)
    (cond
          ;[ (not (sanitycheck f g)) (list #f (list f g))]
          [ (<= (* (size f) (size g)) 1) (if (first (easydual f g varlist)) (list #t (list f g)) (list #f (list f g)))]
          [(simpledisjunction? f g)  (list #t (list f g))] ;catches formulas of the form f: /\_i x_i g: \/_i x_i
          [(simpledisjunction? g f)  (list #t (list f g))]
          [ else
            (letrec ((x (if (empty? pivotlist) (tiebreaker (pivot (sort (vars f) <) f g)) (first pivotlist)))
                          (f0 (remove-var f x))
                          (f1 (remove-clause f x))
                          (g0 (remove-var g x))
                          (g1 (remove-clause g x)))
                 (list (list (representation f) (representation g)) ;node
                       (FK-treelist-guided  f1 (reduce  (disjunction g0 g1)) pivot tiebreaker (remove x varlist) (if (empty? pivotlist) '() (rest pivotlist))) ;left subtree
                       (FK-treelist-guided (reduce (disjunction f0 f1))  g1 pivot tiebreaker (remove x varlist) (if (empty? pivotlist) '() (rest pivotlist)))))]))
;right subtree
(define (FK-treelist f g pivot tiebreaker)
  (FK-treelist-guided f g pivot tiebreaker (vars f) '()))

;treepict is a <tree-layout> (generated by passing a treelist into tree->pict
;arguements: space (list Int/#f Int/#f): the x and y spacing between the nodes, in pixels. set to #f for default spacing.
;            minimal? #t/#f : specify if the generated tree visualization should include the clauses at each node
(define (generate-svg tree filename space minimal)
  ;generates a #tree-layout from a given tree, which can be used to visualise the tree.
  (define (tree->pict tree minimal?)
    (cond [(empty-tree? tree)  (tree-layout #:pict(text (format "~a"  (second tree))))]
        [else  (if minimal?
                   (tree-layout (tree->pict (left-tree tree) #t) (tree->pict (right-tree tree) #t))
                   (tree-layout #:pict(text (format "~a"  (node tree))) (tree->pict (left-tree tree) #f) (tree->pict (right-tree tree) #f)))]))
  (define output (open-output-file filename))
  (fprintf output (bytes->string/utf-8
  (convert (naive-layered (tree->pict tree minimal)  #:x-spacing (first space) #:y-spacing (second space)) 'svg-bytes)))
  (close-output-port output))

;returns a 2D hash table corresponding to the grid, used in the next function.
(define (gridgen tree)
  (define myhash (make-table (length (vars (first (node tree))))))
  (define leftcount-max 0)
  (define (gridgen-help tree leftcount rightcount)
    (when (> leftcount leftcount-max) (set! leftcount-max leftcount))
    (cond [(empty-tree? tree) (K(rightcount leftcount) += 1 in myhash)]
          [else   (begin (gridgen-help (left-tree tree) (+ 1 leftcount) rightcount) (gridgen-help (right-tree tree) leftcount (+ 1 rightcount)))]))
  (gridgen-help tree 0 0)
  (list myhash leftcount-max))

(define (generate-csv filename tree)
  (define outputport (open-output-file filename))
  (letrec ([gridgen-res (gridgen tree)]
           [hash (first gridgen-res)]
           [depth (second gridgen-res)])
   (for ([i (range 0 (+ 1 (length (vars (first (node tree))))))])
     (for([j (range 0 (+ 1 depth))])
       (fprintf outputport "~a," (K(j i) in hash)))
     (fprintf outputport "\n"))
  (close-output-port outputport)))

;generates grids corresponding to all tiebreaking and pivot rules in pivotlist and tblist
(define (generate-all-grids pivotlist tblist f g)
  (define possibilities (cartesian-product pivotlist tblist))
  (for-each (lambda (x)
              (generate-csv (string-replace (string-replace (format "csv\\~a-~a-~a.csv" (first x) (second x) f g) "#<procedure:" "") ">" "")
                        (FK-treelist f g (first x) (second x) (vars f))))
            possibilities))

(define (generate-small-trees n pivot tb)
  (letrec ( [funcs (duals n)]
            [trees (map (lambda (fg) (FK-treelist (first fg) (second fg) pivot tb (vars (first fg)))) funcs)]
            [nontrivial-trees (filter (lambda (x) (= (treecount x (lambda (t) #t)) 7)) trees)]
            [sortedtrees (sort nontrivial-trees (lambda (x y) (< (treecount x (lambda (t) #t)) (treecount y (lambda (t) #t)))))])
    (for ([tree sortedtrees]
          [i (range 0 (+ 1 (length sortedtrees)))])
      (generate-svg  tree
                (string-replace (string-replace (format "smalltrees\\size~a\\~a~arank~a.svg" n pivot tb i) "#<procedure:" "") ">" "") '(10 20) #f))))

(define (find tree formula)
  (define (fhelp tree formula current-path pathlist)
    (cond [(empty-tree? tree) pathlist]
          [(or (equal? (first (node tree)) formula) (equal? (second (node tree)) formula)) (cons current-path pathlist)]
          [else (append (fhelp (right-tree tree) formula (string-append current-path "R") pathlist)
                        (fhelp (left-tree tree) formula (string-append current-path "L") pathlist))]))
  (fhelp tree formula "" empty))

(define (nodeat tree path-string)
  (define listed (string->list path-string))
   (cond [(empty? listed) (node tree)]
         [(eq? (first listed) #\L) (nodeat (left-tree tree) (list->string (cdr listed)))]
         [else (nodeat (right-tree tree) (list->string (cdr listed)))]))

(define (parents tree formula)
  (letrec  [ (mypath (find tree formula))
          (mypathmod (map (lambda (s) (substring s 0 (- (string-length s) 1))) mypath))
          (mynodes (map (lambda (s) (nodeat tree s)) mypathmod))]
  (remove-duplicates mynodes)))



(define var4types (make-hash))
(for [(type typelist)]
  (hash-set! var4types type 0))

(define (vartypes tree )
  (define nodelist (filter (lambda (x) (and (= (length (vars (first x))) 4) (= (length (vars (second x))) 4)))  (tree->list tree)))
  (define var4list (list 'k4 'hw3 'c4 'pan3b 'pan3 'k4- 'path4 'k3d 'd41 'star3 'k2dd))
  (for [(type typelist)]
  (hash-set! var4types type 0))
  (define (update-typecount f)
    (for [(type typelist)]
      (when (is f type)
        (hash-set! var4types type (+ 1 (hash-ref var4types type))))))
  (for [(fpair nodelist)]
        (update-typecount fpair))
  (for ([i var4list])
    (printf "~a\t" (hash-ref var4types i))))


;playground for our experiments

(define (get-dual-data  search-string)
  (define funcdat (string-append search-string ".dat"))
  (define funcddat (string-append search-string "d.dat"))
  (define url (string-append  "http://research.nii.ac.jp/~uno/dualization/" funcdat))
      (system (format "{ cd ../shd ;
                          wget ~a > /dev/null ;
                        ./shd q ~a ~a > /dev/null ;
                       mv -t ../racketbeta ~a ~a
                         } &> /dev/null" url funcdat funcddat funcdat funcddat)))


;(define (testvars pivotlist funclist)
;(for [(func funclist)]
;  (for [(fun func)]
;    (get-dual-data fun)))
; (printf "----done external dualization----\n")
;(for [(func funclist)]
; (for [(fun func)]
;   (letrec [(f  (remove-duplicates (reduce (map (lambda (x) (sort x <)) (get-function-file (string-append fun ".dat"))))))
;    (fd (remove-duplicates (reduce (map (lambda (x) (sort x <)) (get-function-file (string-append fun "d.dat"))))))]
;     (for [(p pivotlist)]
;       (letrec
;           [ (tree (FK-treelist f fd p tbfirst))]
;    (print (string-append (string-replace (string-replace fun "SDFP" "") ".dat" "")
;           (string-replace (string-replace (format "~a" p) "#<procedure:" "-") ">" "")))
;    (printf "\t")
;    (vartypes tree)
;    (printf "\t")
;    (printf "~a\t~a\t~a\t" (length f) (length fd) (leafcount tree)))
;    (newline))))))

(define (testvars pivotlist funclist)
(for [(func funclist)]
 (for [(fun func)]
   (letrec [(f  (remove-duplicates (reduce (map (lambda (x) (sort x <)) (getf (string-append "http://research.nii.ac.jp/~uno/dualization/" (string-append fun ".dat")))))))
            (fd (dual f))]
     (for [(p pivotlist)]
       (letrec
           [ (tree (FK-treelist f fd p tbfirst))]
    (print (string-append (string-replace (string-replace fun "SDFP" "") ".dat" "")
           (string-replace (string-replace (format "~a" p) "#<procedure:" "-") ">" "")))
    (printf "\t")
    (vartypes tree)
    (printf "\t")
    (printf "~a\t~a\t~a\t" (length f) (length fd) (leafcount tree)))
    (newline))))))

(testvars (list fmax fthresh fnone)  (list  
                                          
                                           (list "SDTH42")
                                                                 ))