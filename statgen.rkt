#lang racket
(require "DNF.rkt" "generator.rkt" "fk-1.rkt" "profilegen.rkt" "dualgen.rkt" pict pict/tree-layout file/convertible racket/vector)

; A tree is recursively defined as :
; '(#t/#f '(f g)) : a terminal node, f and g are formulas
; a list '(node l r), where l and r are trees, and node is '(f g) where f and g are formulas at the node
(define (node tree) (car tree))
(define (left-tree tree) (cadr tree))
(define (right-tree tree) (caddr tree))
(define (node-leaf? tree) (member #t tree))
(define (empty-tree? tree) (or (eq? (first tree) #t) (eq? (first tree) #f)))
(define (trivial? tree) (and (not (empty-tree? tree)) (empty-tree? (left-tree tree)) (empty-tree? (right-tree tree))))
(define (tree->list tree)
  (cond
    [(empty-tree? tree) (list (second tree))]
    [else (append  (list (node tree)) (tree->list (left-tree tree)) (tree->list (right-tree tree)))]))

;general function that returns the count of all the nodes in the tree satisfying f
(define (treecount tree f)
  (define (treecount-help tree f count)
    (cond
      [(empty-tree? tree) (if (f (second tree)) 1 0)]
      [else (+ (treecount-help (left-tree tree) f 0)
               (treecount-help (right-tree tree) f 0)
               (if (f (node tree)) 1 0))]))
  (treecount-help tree f 0))

(define (leafcount tree)
  (cond [(empty-tree? tree) 1]
        [else (+ (leafcount (left-tree tree)) (leafcount (right-tree tree)))]))


;generates a #tree-layout from a given tree, which can be used to visualise the tree
(define (tree->pict tree minimal?)
  (cond [(empty-tree? tree) (if minimal? (tree-layout) (tree-layout #:pict(text (format "~a"  (second tree)))))]
        [else  (if minimal?
                   (tree-layout (tree->pict (left-tree tree) #t) (tree->pict (right-tree tree) #t))
                   (tree-layout #:pict(text (format "~a"  (node tree))) (tree->pict (left-tree tree) #f) (tree->pict (right-tree tree) #f)))]))

(define (simpledisjunction? f g)
  (define (listofones g)
    (cond [(empty? g) #t]
          [(= (length (first g)) 1) (listofones (rest g))]
          [else #f]))
  (and (= (length f) 1)
       (listofones g)))
;the following returns a computation tree
(define d1k (make-table 32))
(define dk1 (make-table 32))
(define (FK-treelist-guided f g pivot tiebreaker varlist pivotlist)
    (cond [(or (empty? f) (empty? g)) (list #t (list f g))]
          [ (not (sanitycheck f g)) (list #f (list f g))]
          [ (<= (* (clause-len f) (clause-len g)) 1) (if (first (easydual f g varlist)) (list #t (list f g)) (list #f (list f g)))]
          [(simpledisjunction? f g) (K((length g) 1) += 1 in d1k) (list #t (list f g))] ;catches formulas of the form f: /\_i x_i g: \/_i x_i
          [(simpledisjunction? g f) (K((length f) 1) += 1 in dk1) (list #t (list f g))]
          [ else
            (letrec ((x (if (empty? pivotlist) (tiebreaker (pivot (sort (vars f) <) f g)) (first pivotlist)))
                          (f0 (remove-var f x))
                          (f1 (remove-clause f x))
                          (g0 (remove-var g x))
                          (g1 (remove-clause g x)))
                 (list (list f g) ;node
                       (FK-treelist-guided (reduce f1) (reduce  (disjunction g0 g1)) pivot tiebreaker (remove x varlist) (if (empty? pivotlist) '() (rest pivotlist))) ;left subtree
                       (FK-treelist-guided (reduce (disjunction f0 f1)) (reduce g1) pivot tiebreaker (remove x varlist) (if (empty? pivotlist) '() (rest pivotlist)))))])) ;right subtree
(define (FK-treelist f g pivot tiebreaker varlist)
  (FK-treelist-guided f g pivot tiebreaker varlist '()))

;treepict is a <tree-layout> (generated by passing a treelist into tree->pict
;spacing is the y-spacing between the nodes, set to #f for default spacing
(define (generate-svg tree filename space minimal)
  (define output (open-output-file filename))
  (fprintf output (bytes->string/utf-8
  (convert (naive-layered (tree->pict tree minimal)  #:x-spacing (first space) #:y-spacing (second space)) 'svg-bytes)))
  (close-output-port output))


(define (arrayset dim1 dim2 array)
  (vector-set! (vector-ref array dim1) dim2 (+ 1 (vector-ref (vector-ref array dim1) dim2))))
(define (arrayclear array)
  (vector-map (lambda (y) (vector-fill! y 0)) array))

(define (gridgen tree)
  (define myhash (make-table (length (vars (first (node tree))))))
  (define leftcount-max 0)
  (define (gridgen-help tree leftcount rightcount)
    (when (> leftcount leftcount-max) (set! leftcount-max leftcount))
    (cond [(empty-tree? tree) (K(rightcount leftcount) += 1 in myhash)]
          [else   (begin (gridgen-help (left-tree tree) (+ 1 leftcount) rightcount) (gridgen-help (right-tree tree) leftcount (+ 1 rightcount)))]))
  (gridgen-help tree 0 0)
  (list myhash leftcount-max))

;must first run gridgen to write the values on gridcounters
(define (generate-csv filename tree)
  (define outputport (open-output-file filename))
  (letrec ([gridgen-res (gridgen tree)]
           [hash (first gridgen-res)]
           [depth (second gridgen-res)])
   (for ([i (range 0 (+ 1 (length (vars (first (node tree))))))])
     (for([j (range 0 (+ 1 depth))])
       (fprintf outputport "~a," (K(j i) in hash)))
     (fprintf outputport "\n"))
  ;(vector-map (lambda (x)
  ;           (vector-map (lambda (y) (fprintf outputport "~a," y)) x)
  ;           (fprintf outputport "\n"))
  ;           gridcounters)
  (close-output-port outputport)))

(define (generate-all-grids pivotlist tblist k)
  (define possibilities (cartesian-product pivotlist tblist))
  (for-each (lambda (x)
              ;(gridgen (FK-treelist (f-n k) (g-n k) (first x) (second x) (vars (f-n k))))
              (generate-csv (string-replace (string-replace (format "csv\\~a-~a-f~a-symmetric.csv" (first x) (second x) k) "#<procedure:" "") ">" "")
                        (FK-treelist (f-n k) (g-n k) (first x) (second x) (vars (f-n k)))))    
            possibilities))
(define (print-barrier barrier tree filename)
  (define output (open-output-file filename))
  (define (print-barrier-helper accuml accumr tree)
    (cond [(empty-tree? tree) (if (= accumr barrier) (begin (fprintf output "terminal node: L:~a R:~a  " accuml accumr) (fprintf output "~a\n" (second tree))) #t)]
          [(= accumr barrier) (fprintf output "nonterminal node: L:~a R:~a  " accuml accumr) (fprintf output "~a\n" (node tree)) (print-barrier-helper (+1 accuml) accumr (left-tree tree))]
          [(< accumr barrier) (print-barrier-helper (+ 1 accuml) accumr (left-tree tree)) (print-barrier-helper accuml (+ 1 accumr) (right-tree tree))]
          [else #t]))
  (print-barrier-helper 0 0 tree)
  (close-output-port output))
(define (generate-all-barriers barrier pivotlist tblist)
  (define possibilities (cartesian-product pivotlist tblist))
  (for-each (lambda (x)
              (print-barrier barrier (FK-treelist (f-n 3) (g-n 3) (first x) (second x) (vars (f-n 3)))
               (string-replace (string-replace (format "barriers\\~a-~a-f.txt" (first x) (second x)) "#<procedure:" "") ">" "")))
            possibilities))

(define (generate-small-trees n pivot tb)
  (letrec ( [funcs (duals n)]
            [trees (map (lambda (fg) (FK-treelist (first fg) (second fg) pivot tb (vars (first fg)))) funcs)]
            [nontrivial-trees (filter (lambda (x) (= (treecount x (lambda (t) #t)) 7)) trees)]
            [sortedtrees (sort nontrivial-trees (lambda (x y) (< (treecount x (lambda (t) #t)) (treecount y (lambda (t) #t)))))])
    (for ([tree sortedtrees]
          [i (range 0 (+ 1 (length sortedtrees)))])
      (generate-svg  tree
                (string-replace (string-replace (format "smalltrees\\size~a\\~a~arank~a.svg" n pivot tb i) "#<procedure:" "") ">" "") '(10 20) #f))))

(define (combinationscount n)
  (define formula (combinations (range 1 (* 2 n)) n))
  (treecount (FK-treelist formula formula fnone tbfirst (range 1 (* 2 n))) (lambda (x) #t)))

(define (vartypes tree)
  (define nodelist (filter (lambda (x) (and (= (length (vars (first x))) 4) (= (length (vars (second x))) 4)))  (tree->list tree)))
  (print (length nodelist))
  (define var4types (make-hash))
  (for [(type var4list)]
    (hash-set! var4types (car type) 0))
  (define (update-typecount f g)
    (for [(type var4list)]
      (when (or (isa f (car type)) (isa g (car type)))
         ;(printf "~a\t~a\t~a" f g (car type))
        (hash-set! var4types (car type) (+ 1 (hash-ref var4types (car type)))))))
  (for [(fpair nodelist)]
        (update-typecount (first fpair) (second fpair)))
  (for ([(i j) var4types])
    (printf "~a:\t~a\n" i j)))
  

;(isa '((6 7) (6 8) (5 7) (5 8)) 'pan3)
(define mt (FK-treelist (f-n 3) (g-n 3) fcons tbfirst (vars (f-n 3))))
(define (find tree formula)
  (define (fhelp tree formula current-path pathlist)
    (cond [(empty-tree? tree) pathlist]
          [(or (equal? (first (node tree)) formula) (equal? (second (node tree)) formula)) (cons current-path pathlist)]
          [else (append (fhelp (right-tree tree) formula (string-append current-path "R") pathlist)
                        (fhelp (left-tree tree) formula (string-append current-path "L") pathlist))]))
  (fhelp tree formula "" empty))
(define (nodeat tree path-string)
  (define listed (string->list path-string))
   (cond [(empty? listed) (node tree)]
         [(eq? (first listed) #\L) (nodeat (left-tree tree) (list->string (cdr listed)))]
         [else (nodeat (right-tree tree) (list->string (cdr listed)))]))
       


                   